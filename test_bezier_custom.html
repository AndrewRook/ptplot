



<!DOCTYPE html>
<html lang="en">
  
  <head>
    
      <meta charset="utf-8">
      <title>Bokeh Plot</title>
      
      
        
          
        
        
          
        <script type="text/javascript" src="https://cdn.bokeh.org/bokeh/release/bokeh-2.3.3.min.js" integrity="sha384-dM3QQsP+wXdHg42wTqW85BjZQdLNNIXqlPw/BgKoExPmTG7ZLML4EGqLMfqHT6ON" crossorigin="anonymous"></script>
        <script type="text/javascript">
            Bokeh.set_log_level("info");
        </script>
        <script type="text/javascript">
            (function(root, factory) {
                    factory(root["Bokeh"]);
                })(this, function(Bokeh) {
                  var define;
                  return (function outer(modules, entry) {
                  if (Bokeh != null) {
                    return Bokeh.register_plugin(modules, entry);
                  } else {
                    throw new Error("Cannot find Bokeh. You have to load it prior to loading plugins.");
                  }
                })
                ({
                  "custom/main": function(require, module, exports) {
                    var models = {
                      "BezierFill": require("custom/ptplot.bezier_fill.bezier_fill").BezierFill
                    };
                    require("base").register_models(models);
                    module.exports = models;
                  },
                  "custom/ptplot.bezier_fill.bezier_fill": function(require, module, exports) {
                "use strict";
                var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
                }) : (function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                }));
                var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
                    Object.defineProperty(o, "default", { enumerable: true, value: v });
                }) : function(o, v) {
                    o["default"] = v;
                });
                var __importStar = (this && this.__importStar) || function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
                Object.defineProperty(exports, "__esModule", { value: true });
                exports.BezierFill = exports.BezierFillView = void 0;
                const property_mixins_1 = require("core/property_mixins");
                const glyph_1 = require("models/glyphs/glyph");
                const utils_1 = require("models/glyphs/utils");
                const projections_1 = require("core/util/projections");
                const p = __importStar(require("core/properties"));
                // algorithm adapted from http://stackoverflow.com/a/14429749/3406693
                function _cbb(x0, y0, x1, y1, x2, y2, x3, y3) {
                    const tvalues = [];
                    const bounds = [[], []];
                    for (let i = 0; i <= 2; i++) {
                        let a, b, c;
                        if (i === 0) {
                            b = ((6 * x0) - (12 * x1)) + (6 * x2);
                            a = (((-3 * x0) + (9 * x1)) - (9 * x2)) + (3 * x3);
                            c = (3 * x1) - (3 * x0);
                        }
                        else {
                            b = ((6 * y0) - (12 * y1)) + (6 * y2);
                            a = (((-3 * y0) + (9 * y1)) - (9 * y2)) + (3 * y3);
                            c = (3 * y1) - (3 * y0);
                        }
                        if (Math.abs(a) < 1e-12) { // Numerical robustness
                            if (Math.abs(b) < 1e-12) // Numerical robustness
                                continue;
                            const t = -c / b;
                            if (0 < t && t < 1)
                                tvalues.push(t);
                            continue;
                        }
                        const b2ac = (b * b) - (4 * c * a);
                        const sqrtb2ac = Math.sqrt(b2ac);
                        if (b2ac < 0)
                            continue;
                        const t1 = (-b + sqrtb2ac) / (2 * a);
                        if (0 < t1 && t1 < 1)
                            tvalues.push(t1);
                        const t2 = (-b - sqrtb2ac) / (2 * a);
                        if (0 < t2 && t2 < 1)
                            tvalues.push(t2);
                    }
                    let j = tvalues.length;
                    const jlen = j;
                    while (j--) {
                        const t = tvalues[j];
                        const mt = 1 - t;
                        const x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
                        bounds[0][j] = x;
                        const y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
                        bounds[1][j] = y;
                    }
                    bounds[0][jlen] = x0;
                    bounds[1][jlen] = y0;
                    bounds[0][jlen + 1] = x3;
                    bounds[1][jlen + 1] = y3;
                    return [
                        Math.min(...bounds[0]),
                        Math.max(...bounds[1]),
                        Math.max(...bounds[0]),
                        Math.min(...bounds[1]),
                    ];
                }
                class BezierFillView extends glyph_1.GlyphView {
                    _project_data() {
                        projections_1.inplace.project_xy(this._x0, this._y0);
                        projections_1.inplace.project_xy(this._x1, this._y1);
                    }
                    _index_data(index) {
                        //const {data_size, _x0, _y0, _x1, _y1, _cx0, _cy0, _cx1, _cy1} = this
                        const { data_size, _x0, _y0 } = this;
                        for (let i = 0; i < data_size; i++) {
                            const x0_i = _x0[i];
                            const y0_i = _y0[i];
                            const x1_i = _x0[i]; //_x1[i]
                            const y1_i = _y0[i]; //_y1[i]
                            const cx0_i = _x0[i] - 0.5; //_cx0[i]
                            const cy0_i = _y0[i] + 2; //_cy0[i]
                            const cx1_i = _x0[i] + 0.5; //_cx1[i]
                            const cy1_i = _y0[i] + 2; //_cy1[i]
                            console.log("wooooo");
                            if (isNaN(x0_i + y0_i)) //isNaN(x0_i + x1_i + y0_i + y1_i + cx0_i + cy0_i + cx1_i + cy1_i))
                                index.add_empty();
                            else {
                                const [x0, y0, x1, y1] = _cbb(x0_i, y0_i, x1_i, y1_i, cx0_i, cy0_i, cx1_i, cy1_i);
                                index.add(x0, y0, x1, y1);
                            }
                        }
                    }
                    _render(ctx, indices, data) {
                        if (this.visuals.line.doit) {
                            const { sx0, sy0, sx1, sy1, scx0, scy0, scx1, scy1 } = data !== null && data !== void 0 ? data : this;
                            console.log(sx0, sy0, sx1, sy1, scx0, scy0, scx1, scy1);
                            for (const i of indices) {
                                const sx0_i = sx0[i];
                                const sy0_i = sy0[i];
                                const sx1_i = sx1[i];
                                const sy1_i = sy1[i];
                                const scx0_i = scx0[i];
                                const scy0_i = scy0[i];
                                const scx1_i = scx1[i];
                                const scy1_i = scy1[i];
                                if (isNaN(sx0_i + sy0_i)) //sx1_i + sy1_i + scx0_i + scy0_i + scx1_i + scy1_i))
                                    continue;
                                ctx.beginPath();
                                ctx.moveTo(sx0_i, sy0_i);
                                ctx.bezierCurveTo(scx0_i, scy0_i, scx1_i, scy1_i, sx1_i, sy1_i);
                                if (this.visuals.fill.doit) {
                                    this.visuals.fill.set_vectorize(ctx, i);
                                    ctx.fill();
                                }
                                this.visuals.line.set_vectorize(ctx, i);
                                ctx.stroke();
                            }
                        }
                    }
                    draw_legend_for_index(ctx, bbox, index) {
                        utils_1.generic_line_vector_legend(this.visuals, ctx, bbox, index);
                    }
                    scenterxy() {
                        throw new Error(`${this}.scenterxy() is not implemented`);
                    }
                }
                exports.BezierFillView = BezierFillView;
                BezierFillView.__name__ = "BezierFillView";
                class BezierFill extends glyph_1.Glyph {
                    constructor(attrs) {
                        super(attrs);
                    }
                    static init_BezierFill() {
                        this.prototype.default_view = BezierFillView;
                        this.define(({}) => ({
                            x0: [p.XCoordinateSpec, { field: "x0" }],
                            y0: [p.YCoordinateSpec, { field: "y0" }],
                        }));
                        this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);
                    }
                }
                exports.BezierFill = BezierFill;
                BezierFill.__name__ = "BezierFill";
                BezierFill.init_BezierFill();
                //# sourceMappingURL=bezier_fill.js.map
                }
                }, "custom/main");
                ;
                });

        </script>
        
      
      
    
  </head>
  
  
  <body>
    
      
        
          
          
            
              <div class="bk-root" id="e355cbf9-a92b-45e8-9648-13d3a0fffc84" data-root-id="1003"></div>
            
          
        
      
      
        <script type="application/json" id="1152">
          {"26b1bf77-2b33-47a8-b113-13c1a0e64317":{"defs":[],"roots":{"references":[{"attributes":{},"id":"1045","type":"BasicTickFormatter"},{"attributes":{},"id":"1047","type":"AllLabels"},{"attributes":{"formatter":{"id":"1045"},"major_label_policy":{"id":"1044"},"ticker":{"id":"1013"}},"id":"1012","type":"LinearAxis"},{"attributes":{},"id":"1008","type":"LinearScale"},{"attributes":{},"id":"1048","type":"BasicTickFormatter"},{"attributes":{},"id":"1021","type":"WheelZoomTool"},{"attributes":{"end":7},"id":"1006","type":"Range1d"},{"attributes":{},"id":"1023","type":"SaveTool"},{"attributes":{"bottom_units":"screen","fill_alpha":0.5,"fill_color":"lightgrey","left_units":"screen","level":"overlay","line_alpha":1.0,"line_color":"black","line_dash":[4,4],"line_width":2,"right_units":"screen","syncable":false,"top_units":"screen"},"id":"1026","type":"BoxAnnotation"},{"attributes":{},"id":"1025","type":"HelpTool"},{"attributes":{},"id":"1017","type":"BasicTicker"},{"attributes":{},"id":"1024","type":"ResetTool"},{"attributes":{"source":{"id":"1002"}},"id":"1036","type":"CDSView"},{"attributes":{"end":4},"id":"1004","type":"Range1d"},{"attributes":{"overlay":{"id":"1026"}},"id":"1022","type":"BoxZoomTool"},{"attributes":{},"id":"1010","type":"LinearScale"},{"attributes":{},"id":"1020","type":"PanTool"},{"attributes":{"data_source":{"id":"1002"},"glyph":{"id":"1034"},"hover_glyph":null,"muted_glyph":null,"view":{"id":"1036"}},"id":"1035","type":"GlyphRenderer"},{"attributes":{"axis":{"id":"1016"},"dimension":1,"ticker":null},"id":"1019","type":"Grid"},{"attributes":{},"id":"1013","type":"BasicTicker"},{"attributes":{"fill_color":{"value":"green"},"line_color":{"value":"red"},"x0":{"field":"x"},"y0":{"field":"y2"}},"id":"1034","type":"BezierFill"},{"attributes":{"source":{"id":"1002"}},"id":"1041","type":"CDSView"},{"attributes":{"data":{"cx0":{"__ndarray__":"AAAAAAAA4D8AAAAAAAD4PwAAAAAAAARA","dtype":"float64","order":"little","shape":[3]},"cx1":{"__ndarray__":"AAAAAAAA+D8AAAAAAAAEQAAAAAAAAAxA","dtype":"float64","order":"little","shape":[3]},"cy_1":[3,4,5],"cy_2":[8,7,6],"index":[0,1,2],"x":[1,2,3],"y1":[1,2,3],"y2":[6,5,4]},"selected":{"id":"1051"},"selection_policy":{"id":"1052"}},"id":"1002","type":"ColumnDataSource"},{"attributes":{"cx0":{"field":"cx0"},"cx1":{"field":"cx1"},"cy0":{"field":"cy_1"},"cy1":{"field":"cy_1"},"line_color":{"value":"#1f77b4"},"x0":{"field":"x"},"x1":{"field":"x"},"y0":{"field":"y1"},"y1":{"field":"y1"}},"id":"1038","type":"Bezier"},{"attributes":{"cx0":{"field":"cx0"},"cx1":{"field":"cx1"},"cy0":{"field":"cy_1"},"cy1":{"field":"cy_1"},"line_alpha":{"value":0.1},"line_color":{"value":"#1f77b4"},"x0":{"field":"x"},"x1":{"field":"x"},"y0":{"field":"y1"},"y1":{"field":"y1"}},"id":"1039","type":"Bezier"},{"attributes":{"axis":{"id":"1012"},"ticker":null},"id":"1015","type":"Grid"},{"attributes":{"data_source":{"id":"1002"},"glyph":{"id":"1038"},"hover_glyph":null,"muted_glyph":null,"nonselection_glyph":{"id":"1039"},"view":{"id":"1041"}},"id":"1040","type":"GlyphRenderer"},{"attributes":{"below":[{"id":"1012"}],"center":[{"id":"1015"},{"id":"1019"}],"height":200,"left":[{"id":"1016"}],"renderers":[{"id":"1035"},{"id":"1040"}],"title":{"id":"1042"},"toolbar":{"id":"1027"},"x_range":{"id":"1004"},"x_scale":{"id":"1008"},"y_range":{"id":"1006"},"y_scale":{"id":"1010"}},"id":"1003","subtype":"Figure","type":"Plot"},{"attributes":{"formatter":{"id":"1048"},"major_label_policy":{"id":"1047"},"ticker":{"id":"1017"}},"id":"1016","type":"LinearAxis"},{"attributes":{},"id":"1042","type":"Title"},{"attributes":{"active_multi":null,"tools":[{"id":"1020"},{"id":"1021"},{"id":"1022"},{"id":"1023"},{"id":"1024"},{"id":"1025"}]},"id":"1027","type":"Toolbar"},{"attributes":{},"id":"1051","type":"Selection"},{"attributes":{},"id":"1044","type":"AllLabels"},{"attributes":{},"id":"1052","type":"UnionRenderers"}],"root_ids":["1003"]},"title":"Bokeh Application","version":"2.3.3"}}
        </script>
        <script type="text/javascript">
          (function() {
            var fn = function() {
              Bokeh.safely(function() {
                (function(root) {
                  function embed_document(root) {
                    
                  var docs_json = document.getElementById('1152').textContent;
                  var render_items = [{"docid":"26b1bf77-2b33-47a8-b113-13c1a0e64317","root_ids":["1003"],"roots":{"1003":"e355cbf9-a92b-45e8-9648-13d3a0fffc84"}}];
                  root.Bokeh.embed.embed_items(docs_json, render_items);
                
                  }
                  if (root.Bokeh !== undefined) {
                    embed_document(root);
                  } else {
                    var attempts = 0;
                    var timer = setInterval(function(root) {
                      if (root.Bokeh !== undefined) {
                        clearInterval(timer);
                        embed_document(root);
                      } else {
                        attempts++;
                        if (attempts > 100) {
                          clearInterval(timer);
                          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
                        }
                      }
                    }, 10, root)
                  }
                })(window);
              });
            };
            if (document.readyState != "loading") fn();
            else document.addEventListener("DOMContentLoaded", fn);
          })();
        </script>
    
  </body>
  
</html>